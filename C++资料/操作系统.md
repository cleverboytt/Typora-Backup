1. <font style="background-color:yellow;">进程通信</font>有哪些方式，什么原理

匿名管道：只能用于有亲缘关系的进程间，通过文件描述符访问，半双工

有名管道：无亲缘关系的进程间通信，创建一个特殊的文件

消息队列：存放在内核空间，链表形式保存，如果不读取或者删除会一直保存

共享内存：两个进程不同的虚拟内存映射到同一块物理内存

信号

信号量：一种计数器，用于控制对共享内存的访问，P操作申请资源，V操作释放资源

套接字：不同主机间进行网络通信

2. <font style="background-color:yellow;">进程、线程、协程的区别</font>

进程：

进程是操作系统分配资源的最小单位，每个进程都有自己独立的地址空间和资源进程之间相互独立，不能直接访问对方的资源

进程间切换开销较大，包括保存和恢复进程状态、切换地址空间等，通常由操作系统负责管理线程：

线程是进程内的一个执行单元，是CPU调度的最小单位，多个线程共享同一进程的地址空间和资源，包括全局变量，静态变量等

线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)

线程之间的切换开销较小，通常由操作系统的线程调度器负责管理多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃对其他进程没影响

协程：

协程是一种轻量级的线程，也称为用户态线程或者轻量级线程，它由用户程序控制而不是操作系统控制

协程可以在同一个线程内实现并发执行，通过协作式调度来切换执行权，可以实现非抢占式多任务处理协程之间的切换开销非常小，因为切换是由用户程序自己控制的，不需要操作系统介入协程常用于处理大量的、IO 密集型的并发任务，例如网络编程、异步IO 等场景

，协程是异步

3. <font style="background-color:yellow;">虚拟内存中COW（写时复制）</font>算法的理解

通过写时复制，读时共享，实现在共享资源上进行修改而不影响其他进程（在需要修改共享资源时才复制到私有内存空间中进行修改，以减少不必要的内存拷贝，节省资源）

4. <font style="background-color:yellow;">物理内存和虚拟内存的区别</font>

虚拟内存允许应用程序访问比实际物理内存更大的内存空间。将物理内存与磁盘空间结合，从而使应用程序能够在需要时使用更多的内存。扩展可用内存，共享内存，内存保护（使得不同的进程相互隔离避免冲突）

5. 缺页怎么处理
6. <font style="background-color:yellow;">用户态和内核态的区别</font>

用户态只能受限地访问内存，且不允许访问系统硬件资源，没有占用CPU的能力，CPU资源可以被其它程序获取；内核态可以访问内存所有数据以及系统硬件资源，也可以进行程序的切换

当用户程序需要执行特权操作或访问受限资源时，需要通过系统调用向操作系统发起请求。系统调用会触发由用户态切换到内核态，并将控制权转移到操作系统内核，由内核执行相应的操作。

为什么要分？

安全性，封装性，利于调度

7. 一个进程<font style="background-color:yellow;">open磁盘文件</font>，<font style="background-color:yellow;">read文件</font>，<font style="background-color:yellow;">write</font>，<font style="background-color:yellow;">close</font>过程去判断内核态和用户的执行

<font style="background-color:yellow;">Open:</font>用户态调用open函数，通过系统调用进入内核态，内核进行检查，找到文件描述符返回给用户态；<font style="background-color:yellow;">Read:</font>用户态调用read函数，通过系统调用进入内核态，内核态检验文件描述符，找到文件对象，读取相应字节数到缓冲区，内核将数据从内核缓冲区拷贝到用户进程缓冲区，返回读取字节数给用户进程；<font style="background-color:yellow;">Write:</font> 用户态调用write函数，通过系统调用进入内核态，内核态检验文件描述符，将数据从用户态进程的缓冲区拷贝到内核缓冲区，再将内核缓冲区的数据写入文件，返回写入字节数给用户态进程；<font style="background-color:yellow;">Close:</font> 用户态调用close函数，通过系统调用进入内核态，检查文件描述符合法性，更新文件描述符，并返回。

8. 线程相对进程的优点
9. <font style="background-color:yellow;">用户线程和内核线程之间的映射关系是什么样的</font>

一对一（并发性强，开销大），多对一（并发性差，开销小），一对多

10. <font style="background-color:yellow;">用户线程切换会陷入到内核态嘛</font>

不会，用户线程是在用户空间实现的线程，不是由内核管理，是由用户态的线程库来完成线程的管理，切换也是；

11. 用户进程为什么能比线程做到更轻量
12. <font style="background-color:yellow;">多路复用/epoll、poll、select</font>区别，epoll为什么高效

单个进程/线程可以同时处理多个IO请求。

Select：文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，开销大），由内核根据就绪状态修改该集合的内容。（缺点2：集合大小有限制）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降；poll：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；相比select和poll每次查询都将文件描述符集合从用户空间拷贝到内核空间，epoll在内核空间利用红黑树对文件描述符集合进行了保存，避免了拷贝。此外，epoll在内核空间维护了一个双向链表用于保存就绪的文件描述符，当文件描述符就绪时采用回调机制将该文件描述符加入链表中；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。

13. <font style="background-color:yellow;">线程同步</font>有哪些方式

<font style="background-color:yellow;">互斥锁</font>：互斥锁是内核对象，只有拥有互斥锁的线程才有访问共享资源的权限，保证同一时刻只有一个线程可以访问。<font style="background-color:yellow;">信号量</font>：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。如果为0，则将线程放入一个队列中等待

<font style="background-color:yellow;">条件变量</font>：条件变量用于线程间的同步，通常与互斥锁一起使用，用于等待某个条件成立后再继续执行。<font style="background-color:yellow;">事件</font>：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。<font style="background-color:yellow;">临界区</font>：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放

14. <font style="background-color:yellow;">同步与互斥</font>

同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；互斥：多个进程在同一时刻只有一个进程能运行到临界区

15. <font style="background-color:yellow;">并发、并行和异步</font>

并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；并行：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事

16. <font style="background-color:yellow;">锁有哪些</font>

互斥锁，读写锁，自旋锁（自旋锁是一种忙等待的锁，当线程尝试获取锁时，如果锁已被其他线程占用，该线程将会一直在一个循环中不断地检查锁是否可用），条件变量

17. <font style="background-color:yellow;">进程调度策略</font>有哪些

先来先服务、最短作业优先、最短剩余时间优先、时间片轮转、优先级调度、多级反馈队列调度（多个队列，优先级递减，时间片递增）

18. <font style="background-color:yellow;">阻塞IO和非阻塞IO</font>

阻塞IO：用户执行read，线程被阻塞，直到内核数据准备好通知线程；

非阻塞IO：read后立即返回，此时不断轮询内核（需要主动去检查），询问数据是否准备好；（均为同步）

19. <font style="background-color:yellow;">同步IO和异步IO</font>

异步IO：read后直接返回，内核自动将数据拷贝到用户空间，不用进程自己完成（不需要主动检查），完成后通知进程。

20. <font style="background-color:yellow;">零拷贝</font>

数据不需要从一个内存区域复制到另一个内存区域，从而减少上下文切换和cpu拷贝时间。

普通的文件传输：dma拷贝进内核，read，发生1次cpu拷贝进用户空间和2次上下文切换，write发生1次cpu拷贝进内核空间和2次上下文切换，最后由dma拷贝进硬件。一共4次上下文切换和4次拷贝。mmap+write：内核缓冲区地址与用户缓冲区进行映射，从而实现内存共享，减少一次拷贝，一共4次上下文切换和3次拷贝（1次cpu拷贝从输入缓冲区到输出缓冲区）。sendfile(kafka)：直接由dma完成数据的拷贝，不需要cpu参与，一共2次上下文切换和2次拷贝（没有cpu拷贝）。

21. <font style="background-color:yellow;">死锁产生条件</font>

互斥、占有并等待、非抢占、循环等待

22. <font style="background-color:yellow;">页式存储和段式存储</font>

把虚拟内存和物理内存划分为大小相等的部分称为页，分配时以页为单位。虚拟内存地址被切分为页号和偏移量，根据页号从页表中查询对应的物理页号，加上偏移量后得到物理内存地址。



虚拟内存按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻； 

23. 有哪些<font style="background-color:yellow;">页面置换算法</font>

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

    1. 最佳页面置换算法：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法；
    2. 先进先出FIFO；
    3. 时钟算法：使用环形链表，再使用一个指针指向最老的页面，若其访问位为1，给第二次机会，并将访问位置0；
    4. 最近最少使用算法LRU: 置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

触发页面中断的原因：访问未映射的页面；访问已被置换的页面；

1. <font style="background-color:yellow;">异常控制流：陷阱、中断、异常和信号</font>

陷阱是有意造成的“异常”，是执行一条指令的结果，主要作用是实现系统调用，当进程执行这条指令后，会中断当前的控制流，陷入到内核态；

中断由处理器外部硬件产生，包括I/O中断，定时器引起的时钟中断，断点中断等。分为上半部和下半部分：上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；异常是一种错误情况，是执行当前指令的结果；

信号的作用是用来通知进程发生了某种系统事件

2. <font style="background-color:yellow;">CPU缓存一致性</font>

CPU多个核心的缓存在操作共享数据时，可能造成各核心自己的缓存内数据不一致，要将修改后的数据广播出去，以及多个事务时保证串行化，可以通过MESI协议，将缓存状态定义为修改、独占、共享、失效，来减少总线压力。

