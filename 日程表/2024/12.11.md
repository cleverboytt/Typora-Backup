# 安排

- [ ] C++学习 27/94

  ---

  👇【25】C++构造函数
  ![image-20241211163113268](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20241211163113268.png)

得到的Entity的位置，看似都是随机的值，因为当我们实例化Entity，并为它分配内存时，我们实际上并没有初始化那个内存，这意味中着我们得到了那个内存空间里原来的那些东西。

![image-20241211171119708](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20241211171119708.png)

像这样在类的内部写一个初始化函数，之后再外部调用就能初始例化。但是每次例化都要写这一串来初始化有点太麻烦了，所以就有接下去构造函数的方法。

![image-20241211171921214](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20241211171921214.png)

像这样就不需要再调用**Init**方法了。

> [!CAUTION]
>
> **函数重载**：有相同的函数（方法）名，但是有不同的参数的不同函数版本。 

比如说：
![image-20241211172612634](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20241211172612634.png)

当然，构造函数的方法如果不实例化对象，将不会运行。

当使用**new**关键字并创建一个对象实例时，它也会调用构造函数。

如果对于一个类来说我们不希望人们可以创建它的实例，有两种办法：

1.将其设置为**private**

2.将其用**delete**删除。

![image-20241211173715400](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20241211173715400.png)

---

 👇【26】C++析构函数

- 构造函数：是再创建一个新的实例对象时运行

- 析构函数：是在销毁对象时运行

  析构函数是卸载变量等东西，并清理使用过的内存。 如果使用new分配一个对象，当调用**delete**时，析构函数就会被调用。 **【收回创建对象时申请的空间】**

  ![image-20241211183741725](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20241211183741725.png)

---

 👇【27】C++继承

继承允许我们有一个相互关联的类的层次结构，它允许我们有一个包含公告功能的基类 ，可以从那个基类中分离出来，从最初的父类中创建子类，帮助我们避免代码重复。

我们可以把类之间所有公共功能放在一个父类中，然后从父类创建一些类，可以稍微改变一下功能或者引入全新的功能。 

![image-20241212151059900](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20241212151059900.png)

如上图所示的，任何再Entity类中不是私有的东西，实际上都可以被**Player**访问。

**Player**拥有**Entity**所拥有的一切，再加上多一点的东西。**Player**总是**Entity**的超集。

通过查看**Entity**和**Player**的内存也可以了解他们两个的关系。

```C++
#include<iostream>
class Entity{
public:
    int X;
    int Y;
    void Move(int xa,int ya){
        X+=xa;
        Y+=ya;
    }
};

class Player:public Entity{
public:
    const char* Name="hello";
    void PrintName(){
        std::cout<<Name<<std::endl;
    }
};
int main(){
    Player player;
    player.X=0;
    player.Y=0;
    player.Move(5,10);
    std::cout<<player.X<<","<<player.Y<<std::endl;
    player.PrintName();
    std::cin.get();
}
```

