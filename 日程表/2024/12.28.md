# 安排

- [ ] C++学习 44/94

- [ ] webserver项目

  ---

  👇【43】C++ 对象的生存期
  
  栈可以被认为是一种数据结构，你可以在上面堆叠一些东西。

​	基于栈的变量和基于堆的变量在对象生存期上的区别：

​	基于栈的变量，在我们一出作用域就被释放了，被摧毁了

```C++

#include<iostream>
#include<string>

class Entity{
public:
    Entity(){
        std::cout<<"Entity created"<<std::endl;
    }
    ~Entity(){
        std::cout<<"Entity destroyed"<<std::endl;
    }
};
int main(){
    {
        Entity e;
    }
    std::cin.get();
}

```

​	基于堆的变量，比如说使用`new`运算符在堆上分配的内存，需要我们手动释放。

```C++

#include<iostream>
#include<string>

class Entity{
public:
    Entity(){
        std::cout<<"Entity created"<<std::endl;
    }
    ~Entity(){
        std::cout<<"Entity destroyed"<<std::endl;
    }
};
int main(){
    
    Entity* e=new Entity();
    std::cin.get();
    delete e;
}
```

​	一个例子：

```C++

#include<iostream>
#include<string>

class Entity{
public:
    Entity(){
        std::cout<<"Entity created"<<std::endl;
    }
    ~Entity(){
        std::cout<<"Entity destroyed"<<std::endl;
    }
};

class ScopedPtr{
private:
    Entity* m_Ptr;
public:
    ScopedPtr(Entity* ptr)
        :m_Ptr(ptr){
    } 
    ~ScopedPtr(){
        delete m_Ptr;
    }
};
int main(){
    {
        ScopedPtr e = new Entity();
    }
    std::cin.get();
}
```

- [ScopedPtr](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 类用于管理 [Entity](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 对象的生命周期。
- 它有一个私有成员变量 [m_Ptr](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html)，指向一个 [Entity](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 对象。
- 构造函数接受一个 [Entity*](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 类型的指针，并将其赋值给 [m_Ptr](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html)。
- 析构函数在 [ScopedPtr](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 对象销毁时调用 `delete` 运算符释放 [m_Ptr](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 指向的内存。

---

👇【44】C++ 的智能指针

智能指针本质上是一个原始指针的包装，当你创建一个智能指针，它会调用new并为你分配内存，然后基于你使用的智能指针，这些内存会在某一时刻自动释放。

`unique_ptr`是作用域指针，是超出作用域时，它会被销毁，然后调用`delete`

要访问所有的智能指针，首先要做的是包括`memory`头文件

```C++
#include<iostream>
#include<string>
#include<memory>
class Entity{
public:
    Entity(){
        std::cout<<"Entity created"<<std::endl;
    }
    ~Entity(){
        std::cout<<"Entity destroyed"<<std::endl;
    }

    void print(){}

};
class ScopedPtr{
private:
    Entity* m_Ptr;
public:
    ScopedPtr(Entity* ptr)
        :m_Ptr(ptr){
    } 
    ~ScopedPtr(){
        delete m_Ptr;
    }
};
int main(){
    {
        std::unique_ptr<Entity> entity=std::make_unique<Entity>();
    }
    std::cin.get();
}
```

`std::unique_ptr<Entity>` 表示一个独占所有权的智能指针，管理一个 [Entity](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 类型的对象。`std::make_unique<Entity>()` 创建一个 [Entity](vscode-file://vscode-app/d:/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 对象，并返回一个管理该对象的 `std::unique_ptr<Entity>`。



`shared_ptr`和`weak_ptr`没太看懂QAQ           

---

